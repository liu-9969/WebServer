# 异步日志

* 学习muduo中的日志库  *And ChenShuo YYDS*
* 参考源码来自 ：https://github.com/linyacool/WebServer/tree/master/WebServer/base
* 参考源码解读 ：https://www.codeleading.com/
* 疑问：LogFile的封装并没有起到作用，因为在ThreadFun里就flush一次了，不管数据是多是少，这一次flush完全就把缓冲的数据全部不剩的刷到磁盘了，为什么还要封装每写多少次就flush一次呢？有什么意义吗？



## 1.日志类 概述



* FileUtil:最底层的类了，成员函数离磁盘最近，就是对fwrite、flushh等的封装
* logFile：对FileUtil的封装，增添磁盘刷新频率这样机制，每写1024次就刷新一次磁盘？个人觉得这个文件的作用有问题
* logStream: 自定义日志风格，重载的<<；封装缓冲区类，向外暴露一些首地址、当前可写地址、长度这些信息
* Asynclogger:异步核心区域了，主要规定IO、LOG的交互规则，主要成员函数append()、ThreadFun()。
  * append():IO往缓冲写，并通知后端
  * ThreadFun():LOG从缓冲往磁盘写，写完处于饥饿状态，阻塞等IO线程再次通知。
* Logging:日志库对外提供的接口Log。匿名对象，生命周期就Log<<”正文“这一行，短小但漫长。
* Thread：LOG线程的封装，主要是封装回调函数、pid、lock、con、线程创建、线程分离、线程销毁
* Lock、Condition、CurrentPid:线程同步的封装了；当前线程**pid**的缓存





## 2.日志写到磁盘有什么问题，怎么解决

前提：

* 过程：**程序->内存**(一级缓冲4k)**->缓冲系统**（大块缓冲4M*4）**->文件流缓冲区->磁盘**

* 日志格式例子：2021-08-01 17:26:45  35589  EventLoop start -- HttpServer.cpp:47
* 首先确定的是，不会让业务线程去写磁盘，创建一个LOG线程去做。

要考虑的问题：

1. **程序->内存这段**：c/c++格式化字符串的一些方法
   * sprintf:清晰简单，但是容易越界，类型不安全，效率也不咋样
   
   * std::ostringstream:c++sream风格，清晰，不用担心长度问题，效率不咋样感觉
   * boost::format:
   * muduo采用的第二种方法，出于性能原因，它是自己重载的<<,封装成类。
   
2. **一级缓冲->二级缓冲**：为什么要有这个过度? 这里有没有线程竞争，谁和谁竞争
   * 一条日志也就几十字节，我们不能一条一条的往磁盘写吧，那样往磁盘写日志的线程要哭了。所以先把日志消息汇聚到一块，**原则**上等到积攒足4M，才通知Log线程。用morcpy来操作这一过程，它对直接内存复制，效率很高。
   * IO线程-LOG线程、IO线程-IO线程间有竞争，这是多生产者单消费者模型
   
3. **二级缓冲->文件流缓冲**：上边只考虑了聚集写，但是聚集写带来的时延怎么处理

   * 如果没有有高并发呢，很长时间不够4M呢，所以又设置了时间间隔，每隔2秒往磁盘写一次，就是LOG线程只等条件变量2秒。

   * 首先肯定用fwrite()标准IO,自带缓冲嘛。他的默认缓冲大小不太大。

4. **文件流缓冲->磁盘**：上边只考虑了内存->内存的时延，那内存到磁盘的时延怎么处理？

   * 我们可以setvbuf系列函数指定我们自己缓冲和大小，这里用的64K，几百条日志的大小。
   * 文件是全缓冲的，一般只有写满才会刷到磁盘，就是说，我们大约要写几百条才去刷到磁盘啊，所以不能光考虑高并发聚集写，还要兼顾时延，即LOG每写一次就去flussh一次。





## 3.日志线程运作



### 线程运行图

![在这里插入图片描述](https://img-blog.csdnimg.cn/85e3ece4ef6041fc94fad9c4a257f4b0.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzMxMDA0Mw==,size_16,color_FFFFFF,t_70#pic_center)

code:  LOG<<CurrentThread::tid()<<" EventLoop start"；//发生了什么
结果：2021-08-01 17:26:45  35589  EventLoop start -- HttpServer.cpp:47

**写一条日志的过程**：LOG匿名构造时写入了时间，接下来写入线程PID,正文，在析构时，追加文件和行号，并morcpy到二级缓冲

**写一次磁盘的过程**：等二级缓冲的数据够多了，LOG被唤醒，开始往磁盘写。



​                                     

## 4.异步缓冲原理



#### **1.介绍：**

首先，说他是异步缓冲系统，是因为，异步（严格说是非阻塞）的实现完全基于这个缓冲系统。

如上图，绿色线围成的正方形就是这个缓冲系统，在堆区至少准备了4块缓冲（4M*4），4个智能指针来管理它。

```
每随着程序的执行，每一块BUF的身份都在以下四种交替变化着（shared_ptr的构造和分离来实现身份交换嘛）
```

* CurrentBuf:作为前端IO线程当前正在使用的缓冲
* NextBuf：  作为前端IO线程备用的缓冲--
* RestBuf1： 作为后端log线程正在使用的缓冲
* RestBuf2:  作为后端log线程使用的缓冲



#### **2.异步的原理**（解决多个线程对资源利用的问题）

##### 问题需求：

LOG线程正在往磁盘写，IO线程还能用这块缓冲嘛，反之也是，怎么可以不用等。

##### 解决方案：

1. 同步：就用一块缓冲，通过加锁等待来实现线程有序访问。
2. 异步：用两个以上缓冲，你刷你的，我写我的，不会因为你正在用而去加锁等待，我先往别的地写。

##### 异步原理：

1. 用两个数组来记录这四个缓冲，IO、LOG线程分别拥有一个这样的缓冲数组。
2. IO线程将buf写满后，就push到数组里，然后，这个数组和LOG线程的那个数组交换vector.swap()
3. 这样，IO线程又拿到了新的缓冲，LOG线程可以专心去往磁盘写了。
4. 往复这样的swap循环。

所以，**异步在这**就是不阻塞，不等待，我想做这个事的时候就立马去做。







