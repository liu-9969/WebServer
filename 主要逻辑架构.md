


###### 1. 创建HttpServrer对象，并初始化

	-1.创建非阻塞的监听套接字，并绑定端口，IP
	-2.创建并初始化HttpRequest对象-->listenFd
	-3.创建并初始化线程池--->指定线程个数，线程代码段
	-4.创建并初始化epoll模型 --->
	-5.创建并初始化定时器管理对象--->更新当前时间

###### 2. 运行服务器run()

	-1.监听套接字上树
	-2.注册新连接、断开连接、可读事件、可写事件的回调函数
	-3.事件循环
		 获得最快超时的时间作为epoll_wait的timeout
		 epoll_wait
		 handleevent分发处理，可读可写事件在线程池处理。新连接断开连接在主控线程处理
		 处理定时器队列

###### 3. 接受连接
	-1.因为listenFd是ET，所以要循环accept取连接，直到返回EAGAIN
	-2.用accept4函数接受连接，因为它可以直接设置套接字非阻塞
	-3.为新连接套接字分配HttpRequest资源，并给这个HttpRequest实例安装定时器。
	-4.这些前置工作ok后，将这个套接字挂树上，（LT EPOLLONESHOT！！！！）,
	
	解释：-1循环是因为同一时间内可能有多个连接建立了，而ET只会响应一次，所以一次listenFd就绪，要循环accept
		 从全连接队列中取出所有连接，直到返回EAGAIN

###### 4. 关闭连接
	-1.先判断该连接是否活跃（即这个fd是否还正在进行IO操作），活跃退出
	-2.否则，关掉定时器，释放掉对应的HtppRequest资源（fd的close实在HttpRequest的析构中）

###### 5. 处理可读事件
	-1.首先关掉定时器
	-2.把套接字的数据一次性读到request里的读缓冲区，最里层是readv函数散布读
	-3.根据readv返回值来处理，都各自返回
		1）.==0，说明客户端断开连接了，就关闭连接。
		2）.< 0 EAGAIN不错，关闭连接
		3）.< 0 EAGAIN错误，重新监听它（重装定时器）
		-7.> 0 解析这些数据，解析失败，封装400报文，并发送，最后断开连接
		-8.> 0 解析成功，封装200报文到写缓冲区，不发送，修改套接字事件为（读和写）事件。
		
	解释：-8还监听可读是因为万一可写不立刻触发，这个时间段内又有数据过来了，所以这样可以提高响应速度
	注意：发送缓冲区是在HttpRequest实例中，但是封装的方法是HttpResponse提供的方法。


###### 6. 处理可写事件
	-1.首先关掉定时器，其实在处理读事件后已经释放掉了这个timer资源。
	-2.记录写缓冲有多少数据
		没有数据可写：修该套接字为可读事件，重新安装定时器，返回
		有数据可写：往套接字里一次性写入可写的数据
	-3.根据write返回值来不同处理，各自都会返回
		< 0 EAGAIN不错，关闭连接；
		< 0 EAGAIN错误，没有写入成功，重新监听（读和写），tar again嘛，一有机会就立即去写
		== 可写字节数，刚好写完。
			若长连接，重置解析结果，修改监听事件为可读，重装定时器；
			短连接，关闭连接就行了
		< 可写字节数，没写完呗。
			修改监听事件为（读和写），重装定时器。-------------------------------------------------------没写完一有机会就立刻去写