##### 1.one loop per thread

​			陈硕说的一个one event per thread怎么理解这句话，一个线程一个事件循环？我理解的就是一个客户端对应一个线程，或者，一个事件对应一个线程。而且，我记得之前写多线程的时候，老师就说过，一个线程只负责一件事，主控线程负责揽活（accept）,子线程负责IO。而且自己学习时写过单独的线程池、epoll反应堆、简单httpserver，所以现在就是把那些东西整合到一起。另外也去参考muduo和githab上的开源项目。这样最初模型就出来了，epoll负责事件循环+回调机制。线程池采用生产者消费者模型。

那个简单server的逻辑：之前写过一个单线程的不带定时器的简单httpserver400行，性能还不错逻辑：围绕epoll事件循环拓展，不监听可写，只监听可读，采用ET模式。事件就绪后，分类处理，新连接就去accept，普通fd就先一行一行的读取fd,直到读到最后一个空行。然后http_request（解析+响应），然后断开连接。



##### 2.Timer、HttpRequest类怎么设计、联系、封装。频繁的new和delete怎么处理，处理时机

```


定时器：是用来限定不活跃连接时间的呗。

那这样，每当一个连接建立初，就要安装一个定时器开始计时，考虑到长连接，本次连接完又要重新计时，即重新安装定时器。又考虑到频繁的delete和new,
```

###### 设计思想：

1.参考了github开源项目，一个连接对应一个socket,每个socket分配一个HttpRequest资源，每一个HtppResquest资源绑一个定时器。具体实现就是socket的结构体struct_event里边的ptr指向一个HttpRequest实例，HttpRequest实例回过来以成员变量记录这个socket，以及一个定时器。

2.timer要维护一个开关标量，表示这个定时器有没有意义。

3.管理器要维护一个队列，来记录这些定时器

4.管理器要注册超时回调函数，连接超时且连接noworking就关掉连接



###### new和delete的时机

1.把所有HttpRequest、Timer实例的开辟放到新连接建立函数中。

2.HttpRequest的释放放在连接关闭函数中

3.Timer的释放时机：请求数据到达本地socket后，这个计时器在继续计时就没有意义了，甚至它的存在都没有意义了，因为这次连接已经成功一半了，就等着我去解析和响应了。所以说这个时候直接应该delete掉。而没有必要等到发送完数据。所以我在定时器开辟时维护一个队列，来存放他们，等到读事件添加到线程池后，我就去处理这个队列，delete掉没有意义的定时器。





