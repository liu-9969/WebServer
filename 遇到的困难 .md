# 遇到的困难、bug



##### 1.one loop per thread怎么理解

​			陈硕说的一个one event per thread怎么理解这句话，一个线程一个事件循环？我理解的就是一个客户端对应一个线程，或者，一个事件对应一个线程。而且，我记得之前写多线程的时候，老师就说过，一个线程只负责一件事，主控线程负责揽活（accept）,子线程负责IO。而且自己学习时写过单独的线程池、epoll反应堆、简单httpserver，所以现在就是把那些东西整合到一起。另外也去参考muduo和githab上的开源项目。这样最初模型就出来了，epoll负责事件循环+回调机制。线程池采用生产者消费者模型。

那个简单server的逻辑：之前写过一个单线程的不带定时器的简单httpserver400行，性能还不错逻辑：围绕epoll事件循环拓展，不监听可写，只监听可读，采用ET模式。事件就绪后，分类处理，新连接就去accept，普通fd就先一行一行的读取fd,直到读到最后一个空行。然后http_request（解析+响应），然后断开连接。



##### 2.Timer、HttpRequest类怎么设计、联系、封装。频繁的new和delete怎么处理，处理时机

定时器：是用来限定不活跃连接时间的呗。

那这样，每当一个连接建立初，就要安装一个定时器开始计时，考虑到长连接，本次连接完又要重新计时，即重新安装定时器。又考虑到频繁的delete和new,

###### 设计思想：

1.参考了github开源项目，一个连接对应一个socket,每个socket分配一个HttpRequest资源，每一个HtppResquest资源绑一个定时器。具体实现就是socket的结构体struct_event里边的ptr指向一个HttpRequest实例，HttpRequest实例回过来以成员变量记录这个socket，以及一个定时器。

2.timer要维护一个开关标量，表示这个定时器有没有意义。

3.管理器要维护一个队列，来记录这些定时器

4.管理器要注册超时回调函数，连接超时且连接noworking就关掉连接

###### new和delete的时机

1.把所有HttpRequest、Timer实例的开辟放到新连接建立函数中。

2.HttpRequest的释放放在连接关闭函数中

3.Timer的释放时机：请求数据到达本地socket后，这个计时器在继续计时就没有意义了，甚至它的存在都没有意义了，因为这次连接已经成功一半了，就等着我去解析和响应了。所以说这个时候直接应该delete掉。而没有必要等到发送完数据。所以我在定时器开辟时维护一个队列，来存放他们，等到读事件添加到线程池后，我就去处理这个队列，delete掉没有意义的定时器。



##### 3.堆内存释放错误	


```
问题描述： double free or corruption (fasttop)   free():  
		 double free detected in tcache 2
		 
 bug所在：Timer.cpp::handleTimer()中，while循环条件本应为!timerQueue_.empty();误写为					 timerQueue_.size()

1. 找bug位置：
一开始遇到这个问题，很奇怪，有时候webbench测试5000客户端，60s内不出问题，有时候本地一个浏览器就崩掉。。。
然后上网查了下，无非就是二次释放或内存越界造成的。然后就不知道从哪下手了。。。理了很多遍逻辑，其实只有两个类的实例会delete，像epoll模型，线程池，定时器管理器，他们只有一个实例，又是智能指针管理的，程序运行期间永远不会delete;Buffer、HttpResponse没有在堆上开辟空间。所以这些我都不用考虑了，只有HttpRequest和Timer我需要考虑,这样问题就是出在了连接上，定位好这俩类的delete所在函数，进行打断点单步调试，最后在hangleTimer里边出现 double free detected in tcache 2。到这我确定了是timer的delete出问题了。

2. 改正错误
接下来我就去找怎么“二次释放”的，瞪着眼看这个函数看了很多遍，又理了很多遍逻辑，都没啥问题，gdb我也之只能知道是timer出问题了，我开始考虑是不是内存溢出了，这个函数访问了那个计时器队列，我想是不是访问过头了（其实队列不会溢出，因为只能通过对头出队来访问，不像数组，可以通过下标）。我就开始看循环条件，就是在这，我发现了重大问题，我的循环条件竟然是!timerQueue_.size(),瞬间感觉不对劲。因为我记得当时写的时候它和getNextExprieTime的循环条件一样，立马去对比，果然。。。。。。。
这个条件确实错了，这样这个队列不能正确被处理，改正后，重新测试几遍都没有问题。

3.思考为什么二次释放了
我开始冷静思考，为啥这个bug会时而出来，时而不出来。为啥就二次释放了呢。如下：
主控线程：读事件就绪->handleTimer无效->3getNextExprieTime->处理写->4handleTimer出错
    ​		|
    		|
    		+
 IO线程：  线程池中：a首先关闭timer

​		情况1. 若a比3快，3处就释放掉了timer，4处正好队列空，循环条件满足，程序要再次释放队头元素
			  {{{{{{{{{{{{{{{{{{{
			    但是，此时队列是空的，但是底层数组还没有抹掉这个值，size等于0只是不让我访问，
			    那我硬要访问它也拦不住啊，于是导致释放错误。
			    }}}}}}}}}}}}}}}}}}}}}

​		情况2. 若3比a快，3处不会释放掉timer ，4处不空，循环条件不满足，本次连接没问题

​		但是，所有的连接都是这么个情况，肯定会出现情况1，出现就挂。
```

​	bug逻辑简化

<img src="C:\Users\liu-cc\AppData\Roaming\Typora\typora-user-images\image-20210603153841361.png?lastModify=1624037013" alt="image-20210603153841361" style="zoom:67%;" />

![image-20210603153925365](C:\Users\liu-cc\AppData\Roaming\Typora\typora-user-images\image-20210603153925365.png)

![image-20210603110813038](C:\Users\liu-cc\AppData\Roaming\Typora\typora-user-images\image-20210603110813038.png)