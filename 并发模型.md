##### 1.并发模型：

本程序采用Reactor模型（多线程 + 同步IO + 非阻塞IO + epoll）

尊从**one loop per thread**思想：一个线程服务一个客户端的思想

程序Reactor模型如下图：



```
1.多进程：
	- 可以并发，但不可以并行执行。
	- 每接受一个连接就要fork一个进程来处理请求
	- 缺点：cpu利用率低；创建，切换进程的系统开销很大，比如创建进程需要空间，切换进程需要建立数据表来保存数据				段，堆栈段；进程数上限太低，不利于高并发
2.多线程：
	- 可以并发，多核就可以并行执行；
	- 每接受一个连接就要thread一个线程，来处理请求
	- 优点：可以充分利用cpu，一个IO线程阻塞了，立马可以有其他线程来占用这个核心。
	- 缺点：线程频繁的创建和销毁太占用系统开销，而且线程上限也很低（进程地址空间有限么），不利于高并发

3.事件驱动模型：
	- 一个线程可以监听多个文件描述符，得益于借助于了内核。
	- 一般就是多线程 + 非阻塞IO + 事件循环，采用事件驱动+事件回调方式实现业务逻辑。
	- 结合线程池，避免线程频繁创建销毁，还有用户缓冲区。
	- 优点：可以真正处理高并发业务。
```

##### 2.同步IO和异步IO：

同步IO：操作会引请求起线程阻塞，直到IO完成。或阻塞在epoll_wait、select、poll上，或阻塞在read数据准备阶段，或阻塞在read数据拷贝阶段

异步IO：操作不会引起请求线程阻塞。不关注过程，只等待被通知结果。

##### 3.epoll/select/poll的选择

**任务：**web服务器为IO密集类型，程序的执行事件大多都在IO上，cpu计算很少，服务器核心任务就是接收和响应数据。在这种高并发场景下，最有可能的场景是连接数很多，但是活跃数却很少，这样epoll就比select高效多了。

epoll:内核维采用了高级的数据结构：事件表（红黑树）和就绪队列（双向链表），在每个套接字上树时，内核就在网络设备和该节点间建立了回调关系，一旦数据来了，就把节点添加到就绪队列。而epoll_wait就是从这个队列里拷贝数据到用户去。

select:内核没有建立什么高级数据结构，就是数组。就是挨个遍历每个文件描述符，通过设置mask掩码标记就绪的fd，然后将集合全部拷贝传出到用户区，用户区也不知道哪个fd就绪，需要遍历整个集合，而不管这样是否有意义。