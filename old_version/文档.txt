


/*********************************************************************************************************************************************************************************
 * 创建时间：2021-3-30
 * 修改时间：2021-4-03
 * Author: liuxiangle


 * 程序：简单的web服务器
 * 协议：基于http1.1协议，采用epoll模型实现


 * 模块/思路：
   	1.socket建立连接
        2.建立epoll模型
	3.分类处理epoll就绪事件
	4.处理浏览器来的http请求
	4.封装发送协议头
	5.封装发送目录
	6.封装发送文件
	7.一些转码解码的工作


 * 用到的c库函数：
	 sprintf；
	 int stat(const char *pathname, struct stat *statbuf);		 //判断path属性
	 memset；
	 int strcmp(const char *s1, const char *s2)；		                 //比较字符串
	 int scandir(const char *dirp, struct dirent ***namelist，		//遍历目录，把所有的目录项放到传出参数namelist中（字符指针数组）
	 int (*filter)(const struct dirent *)，
                 int (*compar)(const struct dirent **, const struct dirent **))；
	 int sscanf(const char *str, const char *format, ...);			//从一个字符串中读进与指定格式相符的数据.sscanf("zifuchuan","%[^ ]",buf);
	 strncasecmp；

 * 代码量：450


 * 目标：五月中旬前实现高性能web服务器
 * 
 *





 * coding and funning
   hello 五月---hello liuxiangle---hello web
   hello 五月---hello liuxiangle---hello web
   hello 五月---hello liuxiangle---hello web
   hello 五月---hello liuxiangle---hello web
   hello 五月---hello liuxiangle---hello web





/*********************************************************************************************************************************************************************************



epoll原理：
场景：假设有100万用户与服务器保持着连接，而每一时刻只有几十或几百个连接是活跃的（接收tcp包），我们怎么处理这个问题呢，select / poll? 还是epoll?
一句话：一颗红黑树，一条就绪链表，少量内核缓冲区，解决了以上问题。

当我们调用epoll_create时，内核除了会包我们帮我们创建一颗红黑树外，还会创建一个双向来链表，即循环队列。
所有添加到树上的事件都和设备（如网卡）驱动程序建立回调关系，也就是说，相应的事件发生时，会调用这个方法，这个回调方法在内核中叫ep_oll_callback。它会把这样的事件放到上面的rdllist双向链表中。
epoll红黑树上采用事件异步唤醒，内核监听I/O，事件发生后内核搜索红黑树并将对应节点数据放入异步唤醒的事件队列中
我们为epoll的每一个事件都建立一个结构体，使epoll_event中的联合体epoll_data_t中的ptr指向它。
当我们调用epoll_wait检查是否有发生事件的连接时，只是检查eventpoll对象中的rdllist双向链表是否有epitem元素而已，如果rdllist链表不为空，则这里的事件复制到用户态内存（使用共享内存提高效率）中，同时将事件数量返回给用户。因此epoll_waitx效率非常高。epoll_ctl在向epoll对象中添加、修改、删除事件时，从rbr红黑树中查找事件也非常快，也就是说epoll是非常高效的，它可以轻易地处理百万级别的并发连接


epoll反应堆模型
思想流程：

1）.红黑树fd对应的结构体中的联合体不再是文件描述符本身，而是我们自己封装的结构体。
2）.当epoll_wait返回后，不在分类处理事件，而是直接去调用回调函数，在事件上树前，回调函数已经确定好了，把这个结构体本身传给它就ok。
3）. 监听可读事件–>数据到来–>触发事件–>epoll-wait返回–>
读完数据–>将该结点从树上摘下来–>设置为可写事件和可写回调函数–>重新挂上树–>一些收尾工作（这一行都在回调函数内做）

4） 监听可写事件–>数据到来–>触发事件–>epoll-wait返回–>
写完数据–>将该结点从树上摘下来–>设置为可读事件和可读回调函数–>重新挂上树–>一些收尾工作（这一行都在回调函数内做）

如此频繁的增加删除不是浪费CPU资源吗？
答：对于同一个socket而言，完成收发至少占用两个树上的位置。而交替只需要一个。任何一种设计方式都会有浪费CPU资源的时候，关键看你浪费得值不值，此处的耗费能否换来更大的收益才是衡量是否浪费的标准。和第二个问题综合来看，这里不算浪费

为什么要可读以后设置可写，然后一直交替？
答：服务器的基本工作无非数据的收发，epoll反应堆模型准从TCP模式，一问一答。服务器收到了数据，再给与回复，是目前绝大多数服务器的情况。

(2-1) 服务器能收到数据并不是一定能写数据
假设一 ：服务器接收到客户端数据，刚好此时客户端的接收滑动窗口满，我们假设不进行可写事件设置，并且客户端是有意让自己的接收滑动窗口满的情况(黑客)。那么，当前服务器将随客户端的状态一直阻塞在可写事件，除非你自己在写数据时设置非阻塞+错误处理
假设二 ：客户端在发送完数据后突然由于异常原因停止，这将导致一个FIN发送至服务器，如果服务器不设置可写事件监听，那么在接收数据后写入数据会引发异常SIGPIPE，最终服务器进程终止。




版权声明：本文为CSDN博主「小liu向北」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_43310043/article/details/116111644
